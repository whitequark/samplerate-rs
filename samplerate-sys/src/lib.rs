// bindgen --use-core --no-convert-floats --ctypes-prefix ::libc --raw-line '#![no_std]' --raw-line '#![allow(bad_style)]' samplerate.h >../src/lib.rs
/* automatically generated by rust-bindgen */

#![no_std]
#![allow(bad_style)]

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SRC_STATE_tag {
    _unused: [u8; 0],
}
pub type SRC_STATE = SRC_STATE_tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SRC_DATA {
    pub data_in: *const ::libc::c_float,
    pub data_out: *mut ::libc::c_float,
    pub input_frames: ::libc::c_long,
    pub output_frames: ::libc::c_long,
    pub input_frames_used: ::libc::c_long,
    pub output_frames_gen: ::libc::c_long,
    pub end_of_input: ::libc::c_int,
    pub src_ratio: ::libc::c_double,
}
#[test]
fn bindgen_test_layout_SRC_DATA() {
    assert_eq!(
        ::core::mem::size_of::<SRC_DATA>(),
        64usize,
        concat!("Size of: ", stringify!(SRC_DATA))
    );
    assert_eq!(
        ::core::mem::align_of::<SRC_DATA>(),
        8usize,
        concat!("Alignment of ", stringify!(SRC_DATA))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SRC_DATA>())).data_in as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SRC_DATA),
            "::",
            stringify!(data_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SRC_DATA>())).data_out as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SRC_DATA),
            "::",
            stringify!(data_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SRC_DATA>())).input_frames as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SRC_DATA),
            "::",
            stringify!(input_frames)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SRC_DATA>())).output_frames as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SRC_DATA),
            "::",
            stringify!(output_frames)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SRC_DATA>())).input_frames_used as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SRC_DATA),
            "::",
            stringify!(input_frames_used)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SRC_DATA>())).output_frames_gen as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SRC_DATA),
            "::",
            stringify!(output_frames_gen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SRC_DATA>())).end_of_input as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SRC_DATA),
            "::",
            stringify!(end_of_input)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SRC_DATA>())).src_ratio as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SRC_DATA),
            "::",
            stringify!(src_ratio)
        )
    );
}
pub type src_callback_t = ::core::option::Option<
    unsafe extern "C" fn(
        cb_data: *mut ::libc::c_void,
        data: *mut *mut ::libc::c_float,
    ) -> ::libc::c_long,
>;
extern "C" {
    pub fn src_new(
        converter_type: ::libc::c_int,
        channels: ::libc::c_int,
        error: *mut ::libc::c_int,
    ) -> *mut SRC_STATE;
}
extern "C" {
    pub fn src_callback_new(
        func: src_callback_t,
        converter_type: ::libc::c_int,
        channels: ::libc::c_int,
        error: *mut ::libc::c_int,
        cb_data: *mut ::libc::c_void,
    ) -> *mut SRC_STATE;
}
extern "C" {
    pub fn src_delete(state: *mut SRC_STATE) -> *mut SRC_STATE;
}
extern "C" {
    pub fn src_process(state: *mut SRC_STATE, data: *mut SRC_DATA) -> ::libc::c_int;
}
extern "C" {
    pub fn src_callback_read(
        state: *mut SRC_STATE,
        src_ratio: ::libc::c_double,
        frames: ::libc::c_long,
        data: *mut ::libc::c_float,
    ) -> ::libc::c_long;
}
extern "C" {
    pub fn src_simple(
        data: *mut SRC_DATA,
        converter_type: ::libc::c_int,
        channels: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn src_get_name(converter_type: ::libc::c_int) -> *const ::libc::c_char;
}
extern "C" {
    pub fn src_get_description(converter_type: ::libc::c_int) -> *const ::libc::c_char;
}
extern "C" {
    pub fn src_get_version() -> *const ::libc::c_char;
}
extern "C" {
    pub fn src_set_ratio(state: *mut SRC_STATE, new_ratio: ::libc::c_double) -> ::libc::c_int;
}
extern "C" {
    pub fn src_get_channels(state: *mut SRC_STATE) -> ::libc::c_int;
}
extern "C" {
    pub fn src_reset(state: *mut SRC_STATE) -> ::libc::c_int;
}
extern "C" {
    pub fn src_is_valid_ratio(ratio: ::libc::c_double) -> ::libc::c_int;
}
extern "C" {
    pub fn src_error(state: *mut SRC_STATE) -> ::libc::c_int;
}
extern "C" {
    pub fn src_strerror(error: ::libc::c_int) -> *const ::libc::c_char;
}
pub const SRC_SINC_BEST_QUALITY: _bindgen_ty_1 = 0;
pub const SRC_SINC_MEDIUM_QUALITY: _bindgen_ty_1 = 1;
pub const SRC_SINC_FASTEST: _bindgen_ty_1 = 2;
pub const SRC_ZERO_ORDER_HOLD: _bindgen_ty_1 = 3;
pub const SRC_LINEAR: _bindgen_ty_1 = 4;
pub type _bindgen_ty_1 = u32;
extern "C" {
    pub fn src_short_to_float_array(
        in_: *const ::libc::c_short,
        out: *mut ::libc::c_float,
        len: ::libc::c_int,
    );
}
extern "C" {
    pub fn src_float_to_short_array(
        in_: *const ::libc::c_float,
        out: *mut ::libc::c_short,
        len: ::libc::c_int,
    );
}
extern "C" {
    pub fn src_int_to_float_array(
        in_: *const ::libc::c_int,
        out: *mut ::libc::c_float,
        len: ::libc::c_int,
    );
}
extern "C" {
    pub fn src_float_to_int_array(
        in_: *const ::libc::c_float,
        out: *mut ::libc::c_int,
        len: ::libc::c_int,
    );
}
